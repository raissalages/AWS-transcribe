 Andrew Brown, let's take a look at inputs and outputs or step functions, you need to know this stuff really well in order to actually create step functions, because it is very challenging working with events, permissions, and the syntax. So the idea is that with step functions, you're going to receive JSON event data as input, and then pass the JSON as output. And so this is kind of the big structure here, that we can see here where we have our state input, and it's entering the task, and it's going to follow through these things. But let's take a look at how we can manipulate our JSON payloads. So we have input path, this is to select a portion of the state input, you're using the JSON path syntax to do that. So if you want to select something with it, you can you have parameters. So a task takes parameters, but at that stage, you can change dynamically what you pull out of your input data to pass along it, or just hard code values that you want, we have the result selector, this is kind of like the reverse of parameters. This doesn't really describe it very well, I don't know why I didn't fix that. Then you have the result path, this helps you determine what you want to bring to the end here. Because if you have your state input, you might want to keep it, you might want to discard it. And so that is what result path is for, we have open path that allows you to manipulate it just like the input path for the final output. But let's go take a look at this stuff closer, closer together. And in order to really work with this, while you have to learn the JSON path syntax, to be able to figure out this Amazon state language, that's what the thing is called. But before we move on to all those filter options, let's talk about JSON path. So it's a query language for JSON similar to x path for XML. So imagine we have a bunch of JSON, that's a payload we use in our follow along. So that's a real payload. And you want to select stuff from there. Well, the first thing you can do is use the dollar sign, which will select the root object, you can select children using dotnet notation or bracket notation. So here's an example of how we would select data using JSON path. And that's pretty much the simplest way to do it. For the most part, you're going to be just utilizing the top one, the reason you'd want to use these brackets generally is if you have something that has a weird character in it. And if you're wondering, like, if you don't know how to write JSON path, how can you get really good at it or test it in real time? Well, JSON path.com is pretty good for that. I wanted to just point out with these examples, I made a small mistake and I keep putting input in here. I didn't realize until I did the lab, but input is the input. And so even though it shows it in the interface, it's you're always like this is the actual route that you're selecting from. So here, you just wouldn't do that and just understand that I'm going to have that these examples up here and ignore that. We obviously correct that in the follow along, I don't do that. But anyway, let's just take a look at some of the more advanced features of JSON path. So you have the dollar sign here, you can mix the dot notation in the square brackets, you can select at any depth you want by doing the double dot, you can use wildcards, it's like everything there. And then they have these more complex filters. But I need to point out that these filters do not work in step functions. So if you know JSON path, and you think that you want to use those, you cannot use them. I just want to point out that a reference path is a path whose syntax is limited in such a way that can only identify a single node in the JSON structure, as that is something that kept coming up in the docs reference, reference path. So that's what they're talking about. So how does input path work? Well, very straightforward. You have JSON payload, you put in a JSON path expression, and it's going to select exactly what it is that you want there. So here we are selecting the bucket. Of course, again, this input, we just ignore that. So it's actually dot detail dot bucket. And notice it's returning back the name. So we went in here, we said, detail and the bucket, and then it returned that object there. parameters, the way they work is that you'll have to put this little dollar sign dot dollar sign, because if you don't do that, then it just takes static content, you're basically filling the parameters in for the tasks that you want to execute. So by doing the dot dollar sign, it tells it to interpret the string as JSON path. And so hopefully, that is clear. So here's an example of it with a dollar sign, and then with a static value. Same here. And this is a better example, because this is actually tasks when here's the pass. So parameters, obviously, you'd pass these into a lambda function. And those look like real parameters you would have seen before, we have results selector, I kind of think this as the reverse of parameters, because you can basically take values and then map them into a key object. So that's more important when you're doing map or parallels, but it's something you can do, we have result path. So this lets you do three things, it depends on what you provide to it. So if you just provide the dollar sign, it's only going to return it will only return the output from a task. So you won't get any of your input. If you provide null, it will only provide the input and not the output from the task. If you give it a path, JSON path, it'll actually replace or create a new create a new key in your output parameters. This makes more sense in the lab, because you actually do that for real. All right. And then there's open path. I don't show an example of this because it works exactly like input path. But you can imagine you just select stuff for your final output. And there you go. Okay.