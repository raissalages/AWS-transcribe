 So we're going to walk through all the different types of states with step functions starting with pass state. So for a pass state, the idea here is that it allows us to pass input and output without performing any work. And these are really useful. So let's take a look at the past state and the past state allows you to pass input to its output without performing any work. So I think of this as a dummy or a mock state. And they're really useful when constructing or debugging state machines. When you look at the example application that is set up for you for step functions when you're first getting started, it's all using past states. So the idea is we define a type called pass, we can pass it parameters. That's optional. And these are key value pairs. And this is a way of mocking input, then you have your result. And this is you mocking the the task, they call it a virtual task. In this case, that's going to be passed on to the next state. And then you have result path, which allows you to manipulate where the result will occur. So if we had an output here, the input was ship, which would get passed along, we have our result from our virtual task called government, and we want to insert it at politics. So that is what the output is going to look like. So that is pass states. So now we're going to take a look at a task state. And this is the most important state for step functions, because it's everything that does the work. So for this, there are three types of task states, you have one where it can be performed by a lambda function, you have the case where you can pass parameters to an API actions to services that are supported with step functions, or you can use something which they call an activity. And we'll drill down into all three starting with lambda functions first. So for a lambda function task, here is an example. And the largest takeaway here is look at the resource for the resource where you are passing the ARN. And so that's what's going to trigger that lambda function. And then the result will be whatever's returned from that lambda. Looking at the next case for supported a both services that were accessing the API, here's an example of a batch job. And you are specifying a resource to the to the service in the form of an ARN. And then you have parameters. And these parameters are specific to the service. So it's going to vary per service, you have to look them up. That's how that one's going to work. And as far as I can tell, these are the supported services, maybe there's more. But the documentation wasn't super easy to find on this. I'm thinking lambda batch DynamoDB, ECS, SNS, SQL, SageMaker, EMR, and even step functions, and I'm sure they'll keep on adding more. I wouldn't be surprised if event bridges in this list as well. But this list isn't that important. Because the core ones you need to know is ECS, Fargate, lambda, and probably batch. And then the last case for states or activities, these are a little bit more complicated. This allows you to have a something doing the work outside of AWS, or just hosted somewhere else. So ECS, EC two ECS, and mobile phones, I guess the emphasis is really, whereas when you looked at the lambda function, for step functions, the task was calling it was saying it was going to land and say, do this work here, and report back to me, whereas this one, it waits for someone to pull the the actual state of the task to perform something. So to reiterate here, when some functions reaches an activity task state, the workflow waits for an activity worker to pull for a task. So imagine you get to that state, and you've set up this activity on an EC two instance. That's the EC two instance, this entire time has been pulling waiting for the step function to enter the state. And as soon as it enters that state, then it reports or it activates its job and the reports that back and then the step function moves forward. And here's an example of the code. So this would be the code that you would have to implement on the EC two instance, the lambda function or etc. This is in Ruby, it's obviously in all the SDKs. But you can see you're setting up an activity. And then you have this block of code activity starts that starts the polling. And when that when it actually does pull the input comes in, and then you're going to output those results, and it's going to get sent back there. So those are your three use cases for states, or for task states, and they're definitely the most important. Then we're going to take a look here at choice states. And this allows you to add branching logic to your state machine. So here's an example of that logic, the idea is we choose the type as choice, then we define all our choices, and the conditions, which will cause it to go to the next step. So in the first case, we have a choice where we say, if we have input that's coming in, we have a JSON object, and it has a value of skin, and the skin does not equal pink, then that means it's andorians. And we will choose that as our next state step. If the next case happens, it could be that we have a variable called hearts. And if there's this alien has exactly two hearts, then it must be a Klingon will move on to the Klingon state. The last one here is a bit more complicated, we have an end. So we're combining two statements that have to be true. So if we have an alien that has more than two legs, but less than one mouth, so zero mouths, it must be a fully in and we can also set a default. And so the default here can be Vulcans. So that is choice state. Then we'll take a look here at the weight state. And this delays the state machine for a specific period of time that you specify. So here's one case where we say wait 10 seconds before moving to the next state. And then there's wait until so wait until this exact time. And if you're wondering, you do not have to necessarily provide a hard code value, you can pass in a variable using the timestamp path, which will access it from the input. And then we have our succeed state. So this stops an execution successfully. So here is an example, it's very simple, you'd wonder why would you use this use this when you have the ability to use an end. And it's suggested that these are really great for branches that like when you use the choice, they don't do anything but stop the execution. And saying that something succeeds is very clear. So I think that it's visually it makes a lot more sense than just to end. So that's the success state. And then we have the fail state. So this is the opposite of a success state. And it marks the end and also a failure of the state machine. So here's an example. But we have extra fields here, which success does not have such as the cause and the error. And this is great for having a little bit more information as to what has occurred. Again, you do not have to provide a next or an end because it just stops the state machine. And then we have parallel states. And this allows us to expect two states to be performed. And until they are both performed, not to move forward. So to really make that clear, here's an example where we have two states. So I have a lookup address and lookup phone until both of these complete, it will not move on to the next step. And this is what it looks like. This one is a little bit more complicated to set up. But you know, the only thing you need to remember is that this is what it does. But you can see the left hand side here, we define the parallel, then we define our branches, and we tell where it can start. And we can obviously have even more logic within this. So this can get pretty complex. But yeah, just remember, that's what it does here is it waits for both before it moves in the next step. So the last step here is map. And this one's a lot more complicated that I just didn't want to make five slides for this. So I figured I'd just open the documentation. But the idea here is that map allows you to iterate over an array. So if we scroll down here, as an example, they have a bunch of items in array. And so this state or the state, this map state allows you to iterate through it performing that action. So here, it could perform this lambda function on each single one of these values. But you can see it's very complicated in terms of implementation. But just understand that that's what map does, it allows you to do an iterative process should be really good for inserting records into a database, which I think is a use case that we show in this section here.