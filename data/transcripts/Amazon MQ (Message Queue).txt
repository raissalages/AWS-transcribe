 All right, let's take a look here at Amazon MQ, which is a managed message broker service for the open source projects, active MQ and rabbit MQ. So let's just talk quickly about these two. We have active MQ. It's a powerful open source messaging server that supports a wide range of protocols, including MQP MQTT, stop, JMS, offering robust features for J, J M s. So that's Java messaging system, but I think they renamed it so it's not called Java messaging system. It's something more generic now. But anyway, JMS centric enterprise integrated messaging scenarios. But I want to point out that the protocols that you can actually use with it is JMS, NMS, MQ MQP 1.0, stop MQTT and web sockets. There's supposed to be a comma between these two, I guess that's just a minor mistake. I forgot to put the comma there. The other one is rabbit MQ. This is a highly reliable, scalable and flexible messaging broker that supports advanced messaging protocols like MQP MQTT and stop, making ideal for complex writing scenarios and high throughput requirements. This one only supports MQ and a MQP 091. And so it can support more protocols, but for whatever reason, it was only one to support MQP, which is a disappointment because I really prefer rabbit MQ it is newer than active MQ. And it's a lot more robust in terms of its rules. And I've used it in production before. MQ has a very similar offering to SQS. However, these things are a lot more configurable, you are basically setting up clusters. And so you have to manage instances, it's managed by AWS, but you have to choose your instance size. And if you want to have them running multiple multiple az and things like that. So just understand that they're more managed, but you get a lot more power behind them. Let's just compare these two here. And this is not necessarily the limitations of what AWS imposes, but just what these things do in general. So in terms of protocol support, rabbit MQ supports amq AMQ, p MQTT and stomp, active MQ has more support and also includes open wire. For performance is generally considered faster and more efficient in scenarios with lightweight message and high throughput. Active MQ has good performance, it can offer more features, which can also add more overhead. It's also an older project. So that kind of makes sense. Rabbit MQ has advanced messaging routing capabilities like exchange types for direct topics, headers and fan outs. So we have a lot of options there. That's more to do with AMQ p as well. But there are more capabilities there. Active MQ has basic message messaging routing capabilities with more emphasis on the Java messaging service. Rabbit MQ has basic transactions active MQ has advanced transactions. Act. Rabbit MQ is highly flexible due to the support of multiple messaging protocols and extensive client library support. Active MQ is flexible, especially with Java environments due to its JMS offering a broad range of connectors for the different systems. So active MQ is built in Java, and rabbit MQ is built in Erlang. If you know anything about Erlang, you understand the efficiency of rabbit MQ. But I mean, that's all we really need to know. There's obviously a lot of configuration that goes on with these things, but the exams might not require you to know this in that depth. Okay.